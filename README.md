Задача 1.
а) Да се напише шаблон на функция bool singleChild(graph<T>& g, T const& a),
която проверява дали е вярно, че върхът a е единствено дете на всичките си родители;
б) Път в ориентиран граф наричаме “ласо”, ако всички върхове в него са различни,
с изключение на последния, който съвпада с някой друг връх от пътя.
Пример: пътят 1, 2, 3, 4, 2 е ласо. Да се напише шаблон на функция LList<T> longestLasso(graph<T>& g),
която намира най-дългото ласо в даден граф, или връща празен списък, ако такова няма.
При наличие на няколко най-дълги ласа, да се върне някое от тях.

Задача 2.
а) Да се напише шаблон на функция int countNodes(graph<T>& g),
която намира броя на върховете в графа g, които имат повече родители, отколкото деца;
б) Път в ориентиран граф с числа по върховете наричаме “стълба”,
ако всеки връх е с единица по-голям от предходния, а последният връх е два пъти по-голям от първия.
Пример: пътят 2, 3, 4 е стълба. Да се напише функция LList<int> shortestLadder(graph<int>& g),
която намира най-късата стълба в даден граф, или връща празен списък, ако такава няма.
При наличие на няколко най-къси стълби, да се върне някоя от тях.

Задача 3.
Дадени са граф G с цели числа по върховете и списък L от списъци от цели числа.
Да се провери дали е вярно, че всеки списък в L е последователност от върхове, която образува път в графа G.

Задача 4.
Даден е ориентиран граф G. Да се намери ацикличен път p от a до b, за който е изпълнено следното условие:
в графа G съществува път от b до a, който включва само и единствено върхове от пътя p.
Ако такъв път не съществува, да се върне празен път.

Задача 5.
Дадено е двоично дърво от цифри. Да се напише външна функция,
която проверява дали съществува път от корена на дървото до негово листо, за който е изпълнено следното условие:
числото, което се формира от елементите на пътя в посока от корена на дървото към листото, съвпада с число,
което се формира от елементите на някое ниво X на същото дърво, разглеждани отляво- надясно.
